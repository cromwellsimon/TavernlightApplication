Q4 - Assume all method calls work fine. Fix the memory leak issue in below method

void Game::addItemToPlayer(const std::string& recipient, uint16_t itemId)
{
    Player* player = g_game.getPlayerByName(recipient);
    if (!player) {
        player = new Player(nullptr);
        if (!IOLoginData::loadPlayerByName(player, recipient)) {
            return;
        }
    }

    Item* item = Item::CreateItem(itemId);
    if (!item) {
        return;
    }

    g_game.internalAddItem(player->getInbox(), item, INDEX_WHEREEVER, FLAG_NOLIMIT);

    if (player->isOffline()) {
        IOLoginData::savePlayer(player);
    }
}









The problem here is that a new Player is being constructed in the chance that a Player by the recipient's name isn't found but is never freed. I'm not sure if the best solution is to make a std::unique_ptr<Player> or to just delete(player), but std::unique_ptr<Player> would probably be my go-to.
Another question worth bearing in mind is whether or not Item::CreateItem() follows RAII. If it doesn't, then that could also present another instance of a memory leak. BUT I'm supposed to assume that all method calls work fine so I'm going to assume that this is okay?
Actually, I'm assuming that both of their lifetimes are handled by the g_game.internalAddItem method. If that's the case, then really, it'd only be the player that needs to be deleted in line 9, everything else could remain the same.